"""Game engine for executing actions and managing state transitions."""

from typing import Dict, Any, Tuple, Optional, List, Union
from collections import deque
from ..models.game.game_state import GameState, GameAction, Phase
from ..models.cards.character_card import CharacterCard
from ..models.cards.action_card import ActionCard
from ..models.cards.item_card import ItemCard
from ..models.cards.base_card import Card
from .move_validator import MoveValidator
from .event_system import GameEventManager, GameEvent, EventContext
from .damage_calculator import DamageCalculator, DamageType
from .action_result import ActionResult, ActionResultType
from .choice_system import GameChoiceManager, ChoiceContext
from .step_system import StepProgressionEngine, GameStep, StepType, ExecutionMode, StepStatus
from .input_system import InputManager, PlayerInput, AbilityInputBuilder
from .state_serializer import SnapshotManager
from .game_messages import (
    GameMessage, MessageType, ActionRequiredMessage, ChoiceRequiredMessage, 
    StepExecutedMessage, GameOverMessage, LegalAction
)
from .game_moves import GameMove, ActionMove, ChoiceMove, InkMove, PlayMove, QuestMove, ChallengeMove, SingMove, PassMove
from .action_queue import ActionQueue, ActionPriority, QueuedAction


class GameEngine:
    """Executes game actions and manages state transitions with step-by-step support."""
    
    def __init__(self, game_state: GameState, execution_mode: ExecutionMode = ExecutionMode.PAUSE_ON_INPUT):
        self.game_state = game_state
        self.validator = MoveValidator(game_state)
        self.event_manager = GameEventManager(game_state)
        self.damage_calculator = DamageCalculator(game_state)
        self.choice_manager = GameChoiceManager()
        
        # Step-by-step components (always enabled)
        # Message stream components
        self.message_queue = deque()
        self.current_steps = deque()
        self.waiting_for_input = False
        self.current_choice = None
        
        # Action queue for atomic execution
        self.action_queue = ActionQueue(self.event_manager)
        
        # Step-by-step components
        self.step_engine = StepProgressionEngine(execution_mode)
        self.input_manager = InputManager()
        self.snapshot_manager = SnapshotManager()
        
        # Set up integration
        self.event_manager.set_step_engine(self.step_engine)
        self._setup_step_listeners()
        self._setup_input_handlers()
        
        # Track current action being executed
        self.current_action_steps: List[GameStep] = []
        
        # Conditional effect evaluation
        self._condition_evaluator = None
        
        # Register all triggered abilities from characters currently in play
        self.event_manager.rebuild_listeners()
    
    def start_game(self):
        """Start the game by triggering the initial TURN_BEGINS event."""
        current_player = self.game_state.current_player
        turn_begin_context = EventContext(
            event_type=GameEvent.TURN_BEGINS,
            player=current_player,
            game_state=self.game_state,
            additional_data={'turn_number': self.game_state.turn_number}
        )
        self.event_manager.trigger_event(turn_begin_context)
    
    def get_last_event(self) -> Optional[Dict[str, Any]]:
        """Get the last event that occurred for inspection."""
        return self.game_state.get_last_event()
    
    def clear_last_event(self) -> None:
        """Clear the last event."""
        self.game_state.clear_last_event()
    
    def trigger_event_with_choices(self, event_context: EventContext) -> List[str]:
        """Trigger an event with choice manager included in the context."""
        # Add choice manager to the event context's additional data
        if not event_context.additional_data:
        event_context.additional_data = {}
        event_context.additional_data['choice_manager'] = self.choice_manager
        
        return self.event_manager.trigger_event(event_context)
    
    def draw_card_with_events(self, player):
        """Draw a card for a player and trigger CARD_DRAWN event."""
        card = player.draw_card()
        if card:
            # Set the last event with structured data
            source = "normal_draw"
            if self.game_state.current_phase.value == "draw":
            source = "draw_phase"
            
            self.game_state.set_last_event(
                'CARD_DRAWN',
                player=player.name,
                cards_drawn=[card],
                count=1,
                source=source,
                hand_size_after=len(player.hand),
                deck_size_after=len(player.deck)
            )
            
            # Handle zone transition: card moved from deck to hand
            zone_events = self.game_state.notify_card_zone_change(card, 'deck', 'hand')
            
            # Store zone events for later processing if any
            if zone_events and not hasattr(self, '_pending_zone_events'):
            self._pending_zone_events = []
            if zone_events:
            self._pending_zone_events.extend(zone_events)
            
            # Trigger CARD_DRAWN event
            draw_context = EventContext(
                event_type=GameEvent.CARD_DRAWN,
                source=card,
                player=player,
                game_state=self.game_state
            )
            self.event_manager.trigger_event(draw_context)
        return card
    
    def _execute_set_step(self) -> None:
        """Execute the set step (resolve start-of-turn effects)."""
        # Handle any start-of-turn triggered abilities
        self.game_state.set_step()
    
    def _execute_draw_step(self) -> None:
        """Execute the draw step (draw card with events)."""
        current_player = self.game_state.current_player
        
        # Draw card (skip on first turn for first player)
        should_draw = not (self.game_state.turn_number == 1 and 
                          self.game_state.current_player_index == 0 and 
                          not self.game_state.first_turn_draw_skipped)
        
        if should_draw:
        self.draw_card_with_events(current_player)
        elif self.game_state.turn_number == 1 and self.game_state.current_player_index == 0:
        self.game_state.first_turn_draw_skipped = True
        
        # Don't call draw_step() - we already drew the card with events above
    
    def execute_action(self, action, parameters: Dict[str, Any]) -> ActionResult:
        """Execute a game action and update state."""
        # Convert string actions to GameAction enum if needed
        if isinstance(action, str):
        try:
            action = GameAction(action)
            except ValueError:
            return ActionResult.failure_result(action, f"Unknown action: {action}")
        
        # Check if game is over
        if self.game_state.is_game_over():
        result, winner, reason = self.game_state.get_game_result()
            return ActionResult.failure_result(action, f"Game is over: {reason}")
        
        # Validate action first
        is_valid, message = self.validator.validate_action(action, parameters)
        if not is_valid:
        return ActionResult.failure_result(action, message)
        
        # Record action for stalemate detection
        self.game_state.record_action(action)
        
        # Execute the action
        try:
        if action == GameAction.PLAY_INK:
            return self._execute_play_ink(parameters['card'])
            elif action == GameAction.PLAY_CHARACTER:
            return self._execute_play_character(parameters['card'])
            elif action == GameAction.PLAY_ACTION:
            return self._execute_play_action(parameters['card'])
            elif action == GameAction.PLAY_ITEM:
            return self._execute_play_item(parameters['card'])
            elif action == GameAction.QUEST_CHARACTER:
            return self._execute_quest_character(parameters['character'])
            elif action == GameAction.CHALLENGE_CHARACTER:
            return self._execute_challenge(parameters['attacker'], parameters['defender'])
            elif action == GameAction.SING_SONG:
            return self._execute_sing_song(parameters['song'], parameters['singer'])
            elif action == GameAction.PROGRESS:
            return self._execute_progress()
            elif action == GameAction.PASS_TURN:
            return self._execute_pass_turn()
            else:
            return ActionResult.failure_result(action, f"Unknown action: {action}")
        
        except Exception as e:
        return ActionResult.failure_result(action, f"Error executing action: {str(e)}")
    
    def _execute_play_ink(self, card: Card) -> ActionResult:
        """Execute playing a card as ink."""
        current_player = self.game_state.current_player
        
        if current_player.play_ink(card):
        self.game_state.ink_played_this_turn = True
            self.game_state.actions_this_turn.append(GameAction.PLAY_INK)
            
            # Trigger INK_PLAYED event
            ink_context = EventContext(
                event_type=GameEvent.INK_PLAYED,
                source=card,
                player=current_player,
                game_state=self.game_state
            )
            trigger_results = self.event_manager.trigger_event(ink_context)
            
            return ActionResult.success_result(
                action_type=GameAction.PLAY_INK,
                result_type=ActionResultType.INK_PLAYED,
                card=card,
                player=current_player,
                ink_after=current_player.available_ink,
                total_ink=current_player.total_ink,
                triggered_abilities=trigger_results or []
            )
        
        return ActionResult.failure_result(GameAction.PLAY_INK, "Failed to play ink")
    
    def _execute_play_character(self, character: CharacterCard) -> ActionResult:
        """Execute playing a character card."""
        print(f"DEBUG: _execute_play_character called for {character.name}")
        current_player = self.game_state.current_player
        
        if current_player.play_character(character, character.cost):
        print(f"DEBUG: Successfully played character {character.name}")
            self.game_state.actions_this_turn.append(GameAction.PLAY_CHARACTER)
            
            print(f"DEBUG: Setting turn_played for {character.name}")
            # Set turn_played for ink drying system
            character.turn_played = self.game_state.turn_number
            character.is_dry = False  # Character has wet ink when just played
            
            # Note: Triggered abilities are now part of composable_abilities
            # They will be registered below with the composable abilities
            
            # Register composable abilities this character has
            try:
            print(f"DEBUG: About to register composable abilities for {character.name}")
                print(f"DEBUG: Character {character.name} has {len(character.composable_abilities)} composable abilities")
                for ability in character.composable_abilities:
                print(f"DEBUG: Registering ability {ability.name}")
                    self.event_manager.register_composable_ability(ability)
            except Exception as e:
            print(f"DEBUG: Exception during ability registration: {e}")
                import traceback
                traceback.print_exc()
            
            # Notify zone transition: card moved from hand to play
            # This will handle conditional effect registration/deregistration based on activation zones
            zone_events = self.game_state.notify_card_zone_change(character, 'hand', 'play')
            
            # Store zone events for message processing later
            if zone_events and not hasattr(self, '_pending_zone_events'):
            self._pending_zone_events = []
            if zone_events:
            self._pending_zone_events.extend(zone_events)
            
            # Trigger CHARACTER_ENTERS_PLAY event (more general)
            enters_context = EventContext(
                event_type=GameEvent.CHARACTER_ENTERS_PLAY,
                source=character,
                player=current_player,
                game_state=self.game_state
            )
            trigger_results = self.trigger_event_with_choices(enters_context)
            
            # Trigger CHARACTER_PLAYED event (specific to playing from hand)
            played_context = EventContext(
                event_type=GameEvent.CHARACTER_PLAYED,
                source=character,
                player=current_player,
                game_state=self.game_state
            )
            played_results = self.trigger_event_with_choices(played_context)
            if played_results:
            trigger_results.extend(played_results)
            
            # Include zone events in the result
            result_data = {
                'character': character,
                'player': current_player,
                'ink_after': current_player.available_ink,
                'total_ink': current_player.total_ink,
                'triggered_abilities': trigger_results or []
            }
            
            # Add zone events if any occurred
            if hasattr(self, '_pending_zone_events') and self._pending_zone_events:
            result_data['zone_events'] = self._pending_zone_events.copy()
                self._pending_zone_events.clear()
            
            return ActionResult.success_result(
                action_type=GameAction.PLAY_CHARACTER,
                result_type=ActionResultType.CHARACTER_PLAYED,
                **result_data
            )
        
        return ActionResult.failure_result(GameAction.PLAY_CHARACTER, "Failed to play character")
    
    def _execute_play_action(self, action: ActionCard) -> ActionResult:
        """Execute playing an action card."""
        current_player = self.game_state.current_player
        
        if current_player.play_action(action, action.cost):
        self.game_state.actions_this_turn.append(GameAction.PLAY_ACTION)
            
            # Trigger ACTION_PLAYED event
            action_context = EventContext(
                event_type=GameEvent.ACTION_PLAYED,
                source=action,
                player=current_player,
                game_state=self.game_state
            )
            trigger_results = self.event_manager.trigger_event(action_context)
            
            # If it's a song, also trigger SONG_PLAYED event
            if action.is_song:
            song_context = EventContext(
                    event_type=GameEvent.SONG_PLAYED,
                    source=action,
                    player=current_player,
                    game_state=self.game_state
                )
                song_results = self.event_manager.trigger_event(song_context)
                if song_results:
                trigger_results.extend(song_results)
            
            return ActionResult.success_result(
                action_type=GameAction.PLAY_ACTION,
                result_type=ActionResultType.ACTION_PLAYED,
                action=action,
                player=current_player,
                ink_after=current_player.available_ink,
                total_ink=current_player.total_ink,
                triggered_abilities=trigger_results or []
            )
        
        return ActionResult.failure_result(GameAction.PLAY_ACTION, "Failed to play action")
    
    def _execute_play_item(self, item: ItemCard) -> ActionResult:
        """Execute playing an item card."""
        current_player = self.game_state.current_player
        
        if current_player.play_item(item, item.cost):
        self.game_state.actions_this_turn.append(GameAction.PLAY_ITEM)
            
            # Trigger ITEM_PLAYED event
            item_context = EventContext(
                event_type=GameEvent.ITEM_PLAYED,
                source=item,
                player=current_player,
                game_state=self.game_state
            )
            trigger_results = self.event_manager.trigger_event(item_context)
            
            return ActionResult.success_result(
                action_type=GameAction.PLAY_ITEM,
                result_type=ActionResultType.ITEM_PLAYED,
                item=item,
                player=current_player,
                ink_after=current_player.available_ink,
                total_ink=current_player.total_ink,
                triggered_abilities=trigger_results or []
            )
        
        return ActionResult.failure_result(GameAction.PLAY_ITEM, "Failed to play item")
    
    def _execute_quest_character(self, character: CharacterCard) -> ActionResult:
        """Execute questing with a character."""
        if character.can_quest(self.game_state.turn_number) and not self.game_state.has_character_acted_this_turn(character.id):
        character.exert()
            self.game_state.mark_character_acted(character.id)
            current_player = self.game_state.current_player
            
            # Trigger CHARACTER_QUESTS event BEFORE gaining lore (in case abilities modify lore)
            event_context = EventContext(
                event_type=GameEvent.CHARACTER_QUESTS,
                source=character,
                player=current_player,
                game_state=self.game_state
            )
            trigger_results = self.event_manager.trigger_event(event_context)
            
            # Calculate lore after abilities have had a chance to modify it
            # current_lore already includes all bonuses from abilities
            lore_gained = character.current_lore
            lore_before = current_player.lore
            current_player.gain_lore(lore_gained)
            
            # Trigger LORE_GAINED event
            lore_context = EventContext(
                event_type=GameEvent.LORE_GAINED,
                source=character,
                player=current_player,
                game_state=self.game_state,
                additional_data={'lore_amount': lore_gained}
            )
            lore_results = self.event_manager.trigger_event(lore_context)
            if lore_results:
            trigger_results.extend(lore_results)
            
            # Clear temporary lore bonus
            if hasattr(character, 'temporary_lore_bonus'):
            character.temporary_lore_bonus = 0
            
            self.game_state.actions_this_turn.append(GameAction.QUEST_CHARACTER)
            
            return ActionResult.success_result(
                action_type=GameAction.QUEST_CHARACTER,
                result_type=ActionResultType.CHARACTER_QUESTED,
                character=character,
                player=current_player,
                lore_gained=lore_gained,
                lore_before=lore_before,
                lore_after=current_player.lore,
                triggered_abilities=trigger_results or []
            )
        
        # Check if character has already acted this turn
        if self.game_state.has_character_acted_this_turn(character.id):
        return ActionResult.failure_result(GameAction.QUEST_CHARACTER, "Character has already acted this turn")
        
        return ActionResult.failure_result(GameAction.QUEST_CHARACTER, "Character cannot quest")
    
    def _execute_challenge(self, attacker: CharacterCard, defender: CharacterCard) -> ActionResult:
        """Execute a challenge between characters."""
        if self.game_state.has_character_acted_this_turn(attacker.id):
        return ActionResult.failure_result(GameAction.CHALLENGE_CHARACTER, "Character has already acted this turn")
        
        if not self.validator.can_challenge(attacker, defender):
        return ActionResult.failure_result(GameAction.CHALLENGE_CHARACTER, "Invalid challenge")
        
        # Exert attacker and mark as acted
        attacker.exert()
        self.game_state.mark_character_acted(attacker.id)
        
        # Trigger CHARACTER_CHALLENGES event
        current_player = self.game_state.current_player
        event_context = EventContext(
            event_type=GameEvent.CHARACTER_CHALLENGES,
            source=attacker,
            target=defender,
            player=current_player,
            game_state=self.game_state
        )
        trigger_results = self.event_manager.trigger_event(event_context)
        
        # Calculate damage to defender with ability modifications
        defender_base_damage = attacker.current_strength
        if defender_base_damage > 0:
            # Trigger CHARACTER_TAKES_DAMAGE event BEFORE dealing damage (for Resist, etc.)
            defender_damage_context = EventContext(
                event_type=GameEvent.CHARACTER_TAKES_DAMAGE,
                source=attacker,
                target=defender,
                player=current_player,
                game_state=self.game_state,
                additional_data={
                    'damage': defender_base_damage,
                    'base_damage': defender_base_damage,
                    'damage_type': DamageType.CHALLENGE
                }
            )
            self.event_manager.trigger_event(defender_damage_context)
            
            # Get the modified damage from the event context
            final_defender_damage = defender_damage_context.additional_data.get('damage', defender_base_damage)
            
            # Apply the damage (bypassing damage calculator since we already calculated it via events)
            defender.damage += final_defender_damage
            defender_damage_taken = final_defender_damage
        else:
        defender_damage_taken = 0
        
        # Calculate damage to attacker with ability modifications
        attacker_base_damage = defender.current_strength
        if attacker_base_damage > 0:
            # Trigger CHARACTER_TAKES_DAMAGE event BEFORE dealing damage (for Resist, etc.)
            attacker_damage_context = EventContext(
                event_type=GameEvent.CHARACTER_TAKES_DAMAGE,
                source=defender,
                target=attacker,
                player=self.game_state.opponent,
                game_state=self.game_state,
                additional_data={
                    'damage': attacker_base_damage,
                    'base_damage': attacker_base_damage,
                    'damage_type': DamageType.CHALLENGE
                }
            )
            self.event_manager.trigger_event(attacker_damage_context)
            
            # Get the modified damage from the event context
            final_attacker_damage = attacker_damage_context.additional_data.get('damage', attacker_base_damage)
            
            # Apply the damage (bypassing damage calculator since we already calculated it via events)
            attacker.damage += final_attacker_damage
            attacker_damage_taken = final_attacker_damage
        else:
        attacker_damage_taken = 0
        
        # Remove banished characters and trigger banishment events
        opponent = self.game_state.opponent
        banished_characters = []
        
        if not attacker.is_alive:
            # Trigger CHARACTER_LEAVES_PLAY event (more general)
            leaves_context = EventContext(
                event_type=GameEvent.CHARACTER_LEAVES_PLAY,
                source=attacker,
                player=current_player,
                game_state=self.game_state,
                additional_data={'reason': 'banished'}
            )
            self.event_manager.trigger_event(leaves_context)
            
            # Trigger CHARACTER_BANISHED event BEFORE unregistering abilities
            banish_context = EventContext(
                event_type=GameEvent.CHARACTER_BANISHED,
                source=attacker,
                player=current_player,
                game_state=self.game_state,
                banishment_cause="challenge"
            )
            self.trigger_event_with_choices(banish_context)
            
            # Trigger CHARACTER_BANISHED_IN_CHALLENGE event for abilities that specifically care
            challenge_banish_context = EventContext(
                event_type=GameEvent.CHARACTER_BANISHED_IN_CHALLENGE,
                source=attacker,
                player=current_player,
                game_state=self.game_state
            )
            self.trigger_event_with_choices(challenge_banish_context)
            
            # Now remove from play and unregister abilities
            # Note: Some abilities like RECURRING GUST may have already moved the character to hand
            if attacker in current_player.characters_in_play:
            current_player.characters_in_play.remove(attacker)
                current_player.discard_pile.append(attacker)
            # Unregister composable abilities from banished character
            attacker.unregister_composable_abilities(self.event_manager)
            banished_characters.append(attacker.name)
        
        if not defender.is_alive:
            # Trigger CHARACTER_LEAVES_PLAY event (more general)
            leaves_context = EventContext(
                event_type=GameEvent.CHARACTER_LEAVES_PLAY,
                source=defender,
                player=opponent,
                game_state=self.game_state,
                additional_data={'reason': 'banished'}
            )
            self.event_manager.trigger_event(leaves_context)
            
            # Trigger CHARACTER_BANISHED event BEFORE unregistering abilities
            banish_context = EventContext(
                event_type=GameEvent.CHARACTER_BANISHED,
                source=defender,
                player=opponent,
                game_state=self.game_state,
                banishment_cause="challenge"
            )
            self.trigger_event_with_choices(banish_context)
            
            # Trigger CHARACTER_BANISHED_IN_CHALLENGE event for abilities that specifically care
            challenge_banish_context = EventContext(
                event_type=GameEvent.CHARACTER_BANISHED_IN_CHALLENGE,
                source=defender,
                player=opponent,
                game_state=self.game_state
            )
            self.trigger_event_with_choices(challenge_banish_context)
            
            # Now remove from play and unregister abilities
            # Note: Some abilities like RECURRING GUST may have already moved the character to hand
            if defender in opponent.characters_in_play:
            opponent.characters_in_play.remove(defender)
                opponent.discard_pile.append(defender)
            # Unregister composable abilities from banished character
            defender.unregister_composable_abilities(self.event_manager)
            banished_characters.append(defender.name)
        
        self.game_state.actions_this_turn.append(GameAction.CHALLENGE_CHARACTER)
        
        return ActionResult.success_result(
            action_type=GameAction.CHALLENGE_CHARACTER,
            result_type=ActionResultType.CHARACTER_CHALLENGED,
            attacker=attacker,
            defender=defender,
            player=current_player,
            attacker_damage_taken=attacker_damage_taken,
            defender_damage_taken=defender_damage_taken,
            banished_characters=banished_characters,
            triggered_abilities=trigger_results or []
        )
    
    def _execute_sing_song(self, song: ActionCard, singer: CharacterCard) -> ActionResult:
        """Execute singing a song."""
        current_player = self.game_state.current_player
        
        # Remove song from hand, add to discard
        if song in current_player.hand:
        current_player.hand.remove(song)
            current_player.discard_pile.append(song)
            
            # Exert the singer
            singer.exert()
            
            # Trigger SONG_SUNG event
            event_context = EventContext(
                event_type=GameEvent.SONG_SUNG,
                source=singer,
                target=song,
                player=current_player,
                game_state=self.game_state,
                additional_data={'singer': singer, 'song': song}
            )
            trigger_results = self.event_manager.trigger_event(event_context)
            
            self.game_state.actions_this_turn.append(GameAction.SING_SONG)
            
            return ActionResult.success_result(
                action_type=GameAction.SING_SONG,
                result_type=ActionResultType.SONG_SUNG,
                song=song,
                singer=singer,
                player=current_player,
                triggered_abilities=trigger_results or []
            )
        
        return ActionResult.failure_result(GameAction.SING_SONG, "Failed to sing song")
    
    def _execute_progress(self) -> ActionResult:
        """Execute progressing to the next phase."""
        old_phase = self.game_state.current_phase
        current_player = self.game_state.current_player
        
        # Capture hand/deck state before phase transition for draw detection
        hand_before = len(current_player.hand)
        deck_before = len(current_player.deck)
        
        # Trigger PHASE_ENDS event
        phase_end_context = EventContext(
            event_type=GameEvent.PHASE_ENDS,
            source=old_phase,
            player=current_player,
            game_state=self.game_state,
            additional_data={'phase': old_phase.value}
        )
        self.event_manager.trigger_event(phase_end_context)
        
        # If we're progressing from play phase, end the turn
        if self.game_state.current_phase.value == 'play':
            # Trigger TURN_ENDS event
            turn_end_context = EventContext(
                event_type=GameEvent.TURN_ENDS,
                player=current_player,
                game_state=self.game_state,
                additional_data={'turn_number': self.game_state.turn_number}
            )
            self.event_manager.trigger_event(turn_end_context)
            
            # Advance phase (which will end turn and start new turn)
            old_player_index = self.game_state.current_player_index
            self.game_state.advance_phase()
            
            # If we moved to a new player, trigger TURN_BEGINS
            if self.game_state.current_player_index != old_player_index:
            new_player = self.game_state.current_player
                turn_begin_context = EventContext(
                    event_type=GameEvent.TURN_BEGINS,
                    player=new_player,
                    game_state=self.game_state,
                    additional_data={'turn_number': self.game_state.turn_number}
                )
                self.event_manager.trigger_event(turn_begin_context)
                
                # Trigger READY_STEP event
                ready_context = EventContext(
                    event_type=GameEvent.READY_STEP,
                    player=new_player,
                    game_state=self.game_state
                )
                self.event_manager.trigger_event(ready_context)
                
                # Don't execute ready step here - let the stepped engine handle it
                # Mark that ready step needs to be executed
                self.game_state._needs_ready_step = True
                
                return ActionResult.success_result(
                    action_type=GameAction.PROGRESS,
                    result_type=ActionResultType.TURN_ENDED,
                    old_player=current_player,
                    new_player=new_player,
                    turn_number=self.game_state.turn_number,
                    new_phase=self.game_state.current_phase
                )
        else:
            # Advance phase within the same turn
            self.game_state.advance_phase()
            
            # Trigger PHASE_BEGINS event
            new_phase = self.game_state.current_phase
            phase_begin_context = EventContext(
                event_type=GameEvent.PHASE_BEGINS,
                source=new_phase,
                player=current_player,
                game_state=self.game_state,
                additional_data={'phase': new_phase.value}
            )
            self.event_manager.trigger_event(phase_begin_context)
            
            # Trigger specific phase events and execute phase logic
            result_data = {
                'old_phase': old_phase,
                'new_phase': new_phase,
                'player': current_player
            }
            
            if new_phase.value == 'set':
            set_context = EventContext(
                    event_type=GameEvent.SET_STEP,
                    player=current_player,
                    game_state=self.game_state
                )
                self.event_manager.trigger_event(set_context)
                self._execute_set_step()
                
            elif new_phase.value == 'draw':
            draw_context = EventContext(
                    event_type=GameEvent.DRAW_STEP,
                    player=current_player,
                    game_state=self.game_state
                )
                self.event_manager.trigger_event(draw_context)
                
                # Use the event-aware draw method instead of direct draw_step
                self._execute_draw_step()
                
                # Check if cards were drawn
                hand_after = len(current_player.hand)
                deck_after = len(current_player.deck)
                cards_drawn = hand_after - hand_before
                
                # Get draw events from the game state
                draw_events = []
                if cards_drawn > 0:
                    # Find the most recent card drawn event
                    last_event = self.game_state.get_last_event()
                    if last_event and last_event.get('type') == 'CARD_DRAWN':
                    cards_drawn_names = [card.name for card in last_event.get('cards_drawn', [])]
                        if cards_drawn_names:
                        draw_events = [f"{current_player.name} drew {card_name}" for card_name in cards_drawn_names]
                
                result_data.update({
                    'card_drawn': cards_drawn > 0,
                    'cards_drawn': cards_drawn,
                    'hand_size': hand_after,
                    'deck_size': deck_after,
                    'first_player_first_turn': (self.game_state.turn_number == 1 and 
                                              self.game_state.current_player_index == 0),
                    'draw_events': draw_events
                })
                
                # Include zone events from drawing if any occurred
                if hasattr(self, '_pending_zone_events') and self._pending_zone_events:
                result_data['zone_events'] = self._pending_zone_events.copy()
                    self._pending_zone_events.clear()
                
            elif new_phase.value == 'play':
            play_context = EventContext(
                    event_type=GameEvent.MAIN_PHASE_BEGINS,
                    player=current_player,
                    game_state=self.game_state
                )
                self.event_manager.trigger_event(play_context)
            
            return ActionResult.success_result(
                action_type=GameAction.PROGRESS,
                result_type=ActionResultType.PHASE_ADVANCED,
                **result_data
            )
    
    def _execute_pass_turn(self) -> ActionResult:
        """Execute passing the turn to the opponent."""
        old_phase = self.game_state.current_phase
        current_player = self.game_state.current_player
        
        # Trigger PHASE_ENDS event
        phase_end_context = EventContext(
            event_type=GameEvent.PHASE_ENDS,
            source=old_phase,
            player=current_player,
            game_state=self.game_state,
            additional_data={'phase': old_phase.value}
        )
        self.event_manager.trigger_event(phase_end_context)
        
        # Trigger TURN_ENDS event
        turn_end_context = EventContext(
            event_type=GameEvent.TURN_ENDS,
            player=current_player,
            game_state=self.game_state,
            additional_data={'turn_number': self.game_state.turn_number}
        )
        self.event_manager.trigger_event(turn_end_context)
        
        # End turn and start next player's turn
        old_player_index = self.game_state.current_player_index
        self.game_state.end_turn()
        
        # Evaluate conditional effects now that turn has actually changed
        turn_change_events = self.game_state.evaluate_conditional_effects()
        
        # Store turn change events for stepped engine processing
        if turn_change_events and not hasattr(self, '_pending_zone_events'):
        self._pending_zone_events = []
        if turn_change_events:
        self._pending_zone_events.extend(turn_change_events)
        
        # Trigger TURN_BEGINS for new player
        new_player = self.game_state.current_player
        turn_begin_context = EventContext(
            event_type=GameEvent.TURN_BEGINS,
            player=new_player,
            game_state=self.game_state,
            additional_data={'turn_number': self.game_state.turn_number}
        )
        self.event_manager.trigger_event(turn_begin_context)
        
        # Trigger READY_STEP event
        ready_context = EventContext(
            event_type=GameEvent.READY_STEP,
            player=new_player,
            game_state=self.game_state
        )
        self.event_manager.trigger_event(ready_context)
        
        # Don't execute ready step here - let the stepped engine handle it
        # Mark that ready step needs to be executed
        self.game_state._needs_ready_step = True
        
        # Include turn change events in the result
        result_data = {
            'old_player': current_player,
            'new_player': new_player,
            'turn_number': self.game_state.turn_number,
            'new_phase': self.game_state.current_phase
        }
        
        # Add turn change events if any occurred
        if hasattr(self, '_pending_zone_events') and self._pending_zone_events:
        result_data['zone_events'] = self._pending_zone_events.copy()
            self._pending_zone_events.clear()
        
        return ActionResult.success_result(
            action_type=GameAction.PASS_TURN,
            result_type=ActionResultType.TURN_ENDED,
            **result_data
        )
    
    # =============================================================================
    # PLAYER CHOICE SYSTEM METHODS
    # =============================================================================
    
    def is_paused_for_choice(self) -> bool:
        """Check if the game is paused waiting for a player choice."""
        return self.choice_manager.is_game_paused()
    
    def get_current_choice(self) -> Optional[ChoiceContext]:
        """Get the current choice that needs player input."""
        return self.choice_manager.get_current_choice()
    
    def provide_player_choice(self, choice_id: str, selected_option: str) -> bool:
        """
        Provide a player's choice and continue game execution.
        
        Args:
        choice_id: ID of the choice being answered
            selected_option: ID of the selected option
            
        Returns:
        True if choice was valid and executed, False otherwise
        """
        return self.choice_manager.provide_choice(choice_id, selected_option)
    
    def auto_resolve_choices(self) -> int:
        """
        Auto-resolve all pending choices with their default options.
        Useful for automated play or testing.
        
        Returns:
        Number of choices that were auto-resolved
        """
        return self.choice_manager.auto_resolve_with_defaults()
    
    def clear_all_choices(self) -> None:
        """Clear all pending choices and resume the game. Use with caution."""
        self.choice_manager.clear_all_choices()
    
    def get_choice_summary(self) -> Dict[str, Any]:
        """Get a summary of the current choice state for debugging/UI."""
        current_choice = self.get_current_choice()
        return {
            'is_paused': self.is_paused_for_choice(),
            'pending_choices': len(self.choice_manager.pending_choices),
            'current_choice': {
                'id': current_choice.choice_id if current_choice else None,
                'player': current_choice.player.name if current_choice and current_choice.player else None,
                'ability': current_choice.ability_name if current_choice else None,
                'prompt': current_choice.prompt if current_choice else None,
                'options': [opt.id for opt in current_choice.options] if current_choice else []
            } if current_choice else None
        }

    # =============================================================================
    # STEP-BY-STEP SYSTEM METHODS
    # =============================================================================
    
    def execute_action_with_override(self, action, parameters):
        """Override execute_action to capture and queue event messages."""
        # Capture last event before action
        last_event_before = self.get_last_event()
        timestamp_before = last_event_before.get('timestamp', -1) if last_event_before else -1
        
        # Execute the action using parent implementation
        result = self.execute_action(action, parameters)
        
        # Check for new events and queue messages
        last_event_after = self.get_last_event()
        timestamp_after = last_event_after.get('timestamp', -1) if last_event_after else -1
        
        # If there's a new event, queue a message for it
        if last_event_after and timestamp_after > timestamp_before:
        self._queue_game_event_message(last_event_after)
        
        # Check for ability triggers during draw phase
        if action.value == 'PROGRESS' and self.game_state.current_phase.value == 'draw':
        self._check_for_ability_triggers()
        
        return result
    
    def next_message(self, move: Optional[GameMove] = None) -> GameMessage:
        """Get the next message in the game progression."""
        # Process move if provided
        if move and self.waiting_for_input:
        self._process_move(move)
            self.waiting_for_input = False
            
            # Evaluate conditional effects after move processing
            self._evaluate_conditional_effects_after_move(move)
        
        # Return queued messages first
        if self.message_queue:
        message = self.message_queue.popleft()
            # Apply deferred action if this message has one
            if hasattr(message, 'deferred_action') and message.deferred_action:
                # Apply the deferred effect now
                try:
                result = message.deferred_action.effect.apply(message.deferred_action.target, message.deferred_action.context)
                except Exception as e:
                print(f"DEBUG: Error applying deferred action: {e}")
            return message
        
        # Process pending actions from action queue (highest priority)
        if self.action_queue.has_pending_actions():
        message = self._process_next_queued_action()
            if message:
            return message
        
        # Execute next step if available
        if self.current_steps:
        message = self._execute_next_step()
            
            # Evaluate conditional effects after step execution
            self._evaluate_conditional_effects_after_step()
            
            return message
        
        # Check for choices
        if self.current_choice or self.is_paused_for_choice():
        if not self.current_choice:
            self.current_choice = self.get_current_choice()
            
            if self.current_choice:
            self.waiting_for_input = True
                return ChoiceRequiredMessage(
                    type=MessageType.CHOICE_REQUIRED,
                    player=self.current_choice.player,
                    choice=self.current_choice,
                    ability_source=getattr(self.current_choice, 'source', None)
                )
        
        # Check game over
        if self.game_state.is_game_over():
        result, winner, game_over_data = self.game_state.get_game_result()
            # Build reason string from game_over_data for backward compatibility
            reason = ""
            if game_over_data:
            context = game_over_data.get('context', {})
                result_type = context.get('result')
                if result_type == 'lore_victory':
                winner_name = context.get('winner_name', 'Unknown')
                    lore = context.get('lore', 0)
                    reason = f"{winner_name} wins with {lore} lore!"
                elif result_type == 'deck_exhaustion':
                winner_name = context.get('winner_name', 'Unknown')
                    loser_name = context.get('loser_name', 'Unknown')
                    reason = f"{winner_name} wins - {loser_name} ran out of cards!"
                elif result_type == 'stalemate':
                reason = "Game ended in stalemate - both players unable to make progress"
            
            return GameOverMessage(
                type=MessageType.GAME_OVER,
                player=self.game_state.current_player,
                winner=winner,
                reason=reason
            )
        
        # Need player action
        self.waiting_for_input = True
        return ActionRequiredMessage(
            type=MessageType.ACTION_REQUIRED,
            player=self.game_state.current_player,
            phase=self.game_state.current_phase,
            legal_actions=self._get_legal_actions()
        )
    
    def execute_action_stepped(self, action: GameAction, parameters: Dict[str, Any]) -> Tuple[bool, str]:
        """Execute a game action using step-by-step progression."""
        # Validate action first
        is_valid, message = self.validator.validate_action(action, parameters)
        if not is_valid:
        return False, message
        
        # Create steps for the action
        action_steps = self._create_action_steps(action, parameters)
        if not action_steps:
            # Fall back to immediate execution for actions without steps
            result = self.execute_action(action, parameters)
            return result.success, str(result)
        
        # Queue the steps
        self.current_action_steps = action_steps
        self.step_engine.queue_steps(action_steps)
        
        # Start execution
        if self.step_engine.step_queue.execution_mode == ExecutionMode.PAUSE_ON_INPUT:
            # Auto-advance until input needed
            executed_steps = self.step_engine.continue_execution()
            return True, f"Started {action.value} execution ({len(executed_steps)} steps completed)"
        else:
            # Manual mode - execute first step only
            first_step = self.step_engine.execute_next_step()
            if first_step:
            return True, f"Started {action.value} execution (step: {first_step.description})"
            else:
            return False, "Failed to start action execution"
    
    def advance_step(self) -> Optional[GameStep]:
        """Advance to the next step in manual mode (step mode only)."""
        return self.step_engine.execute_next_step()
    
    def provide_input_for_current_step(self, input_data: Any) -> Optional[GameStep]:
        """Provide input for the current step that's waiting for input (step mode only)."""
        return self.step_engine.provide_input(input_data)
    
    def get_current_step(self) -> Optional[GameStep]:
        """Get the current step being executed (step mode only)."""
        return self.step_engine.get_current_step()
    
    def get_step_queue_status(self) -> Dict[str, Any]:
        """Get the current status of the step queue (step mode only)."""
        return self.step_engine.get_queue_state()
    
    def pause_execution(self) -> None:
        """Pause step execution (step mode only)."""
        self.step_engine.pause()
    
    def resume_execution(self) -> None:
        """Resume step execution."""
        self.step_engine.resume()
    
    def clear_step_queue(self) -> None:
        """Clear the step queue."""
        self.step_engine.clear_queue()
        self.current_action_steps.clear()
    
    def set_execution_mode(self, mode: ExecutionMode) -> None:
        """Set the execution mode (step mode only)."""
        self.step_engine.step_queue.execution_mode = mode
    
    def register_player_input_provider(self, player_id: str, provider) -> None:
        """Register an input provider for a player."""
        self.input_manager.register_input_provider(player_id, provider)
    
    def force_evaluate_conditional_effects(self) -> None:
        """Force evaluation of all conditional effects."""
        from ..models.abilities.composable.condition_evaluator import EvaluationTrigger
        
        events = self.condition_evaluator.evaluate_all_conditions(
            self.game_state, 
            EvaluationTrigger.FORCE_EVALUATE
        )
        self._queue_conditional_effect_events(events)
    
    def trigger_event_with_choices_and_queue(self, event_context: EventContext) -> List[str]:
        """Trigger an event with choice manager and action queue included in the context."""
        # Add choice manager and action queue to the event context's additional data
        if not event_context.additional_data:
        event_context.additional_data = {}
        event_context.additional_data['choice_manager'] = self.choice_manager
        event_context.additional_data['action_queue'] = self.action_queue
        
        return self.event_manager.trigger_event(event_context)
    
    # =============================================================================
    # STEP-BY-STEP INTERNAL METHODS
    # =============================================================================
    
    def _queue_game_event_message(self, event: dict) -> None:
        """Queue a message for a game event from the regular game engine."""
            
        event_type = event.get('type')
        player_name = event.get('player', 'Unknown')
        
        if event_type == 'card_drawn':
            # Queue draw event message
            cards_drawn = event.get('cards_drawn', [])
            for card in cards_drawn:
            card_name = card.name if hasattr(card, 'name') else 'Unknown Card'
                draw_message = StepExecutedMessage(
                    type=MessageType.STEP_EXECUTED,
                    player=self.game_state.current_player,
                    step_id=f"card_drawn_{card_name}",
                    description=f" {player_name} drew {card_name}",
                    result="Drew"
                )
                self.message_queue.append(draw_message)
    
    def _check_for_ability_triggers(self) -> None:
        """Check for ability triggers and queue messages for them."""
            
        # Check if Royal Guard has gained challenger bonus (indicating HEAVILY ARMED triggered)
        current_player = self.game_state.current_player
        for character in current_player.characters_in_play:
        if character.name == "Royal Guard" and character.current_challenger_bonus > 0:
                # Check if this is a new bonus from this turn
                for amount, duration in character.challenger_bonuses:
                if duration in ["turn", "this_turn"]:
                    ability_message = StepExecutedMessage(
                            type=MessageType.STEP_EXECUTED,
                            player=current_player,
                            step_id=f"heavily_armed_trigger",
                            description=f" {character.name} gained Challenger +{amount} from HEAVILY ARMED",
                            result="Activated"
                        )
                        self.message_queue.append(ability_message)
                        break
    
    def _process_move(self, move: GameMove) -> None:
        """Process a player move."""
            
        if isinstance(move, ActionMove):
            # Break action into steps and queue them
            steps = self._create_action_steps(move.action, move.parameters)
            if steps:
            self.current_steps.extend(steps)
            else:
                # Fall back to direct execution if no steps created
                result = self.execute_action(move.action, move.parameters)
                self._queue_result_message(result)
            
        elif isinstance(move, (InkMove, PlayMove, QuestMove, ChallengeMove, SingMove)):
            # Convert specific moves to action moves
            action_move = self._convert_to_action_move(move)
            steps = self._create_action_steps(action_move.action, action_move.parameters)
            if steps:
            self.current_steps.extend(steps)
            else:
                # Fall back to direct execution if no steps created
                result = self.execute_action(action_move.action, action_move.parameters)
                self._queue_result_message(result)
            
        elif isinstance(move, PassMove):
            # Handle pass/progress
            # If we're in ready phase and this is the start of a new turn, execute ready step first
            if (self.game_state.current_phase.value == 'ready' and 
                hasattr(self.game_state, '_needs_ready_step')):
            readied_items = self.game_state.ready_step()
                # Queue ready step messages
                for readied_item in readied_items:
                ready_message = StepExecutedMessage(
                        type=MessageType.STEP_EXECUTED,
                        player=self.game_state.current_player,
                        step_id=f"character_readied",
                        description="Character readied",  # Generic description
                        result="Readied",
                        event_data=readied_item  # Pass the full event data
                    )
                    self.message_queue.append(ready_message)
                # Clear the flag
                delattr(self.game_state, '_needs_ready_step')
            
            result = self.execute_action(GameAction.PROGRESS, {})
            self._queue_result_message(result)
            
        elif isinstance(move, ChoiceMove):
            # Resolve choice and continue
            self._resolve_choice(move.choice_id, move.option)
            self.current_choice = None
    
    def _convert_to_action_move(self, move: GameMove) -> ActionMove:
        """Convert specific move types to generic action moves."""
        if isinstance(move, InkMove):
        return ActionMove(GameAction.PLAY_INK, {'card': move.card})
        elif isinstance(move, PlayMove):
        if isinstance(move.card, CharacterCard):
            return ActionMove(GameAction.PLAY_CHARACTER, {'card': move.card})
            elif isinstance(move.card, ActionCard):
            return ActionMove(GameAction.PLAY_ACTION, {'card': move.card})
            elif isinstance(move.card, ItemCard):
            return ActionMove(GameAction.PLAY_ITEM, {'card': move.card})
        elif isinstance(move, QuestMove):
        return ActionMove(GameAction.QUEST_CHARACTER, {'character': move.character})
        elif isinstance(move, ChallengeMove):
        return ActionMove(GameAction.CHALLENGE_CHARACTER, {'attacker': move.attacker, 'defender': move.defender})
        elif isinstance(move, SingMove):
        return ActionMove(GameAction.SING_SONG, {'singer': move.singer, 'song': move.song})
        
        raise ValueError(f"Cannot convert move type: {type(move)}")
    
    def _create_action_steps(self, action: GameAction, parameters: Dict[str, Any]) -> List[GameStep]:
        """Create steps for a game action."""
        # For now, disable step creation to use clean direct execution
        # This ensures all actions use the new clean messaging format
        return []
    
    def _execute_next_step(self) -> StepExecutedMessage:
        """Execute the next step and return message."""
            
        step = self.current_steps.popleft()
        
        try:
        result = step.execute_fn()
            step.status = StepStatus.COMPLETED
            step.result = result
            
            # Check if step triggered a choice
            if self.is_paused_for_choice():
            self.current_choice = self.get_current_choice()
            
            return StepExecutedMessage(
                type=MessageType.STEP_EXECUTED,
                player=self.game_state.current_player,
                step_id=step.step_id,
                description=step.description,
                result=str(result) if result else "Completed"
            )
            
        except Exception as e:
        step.status = StepStatus.CANCELLED
            step.error = str(e)
            return StepExecutedMessage(
                type=MessageType.STEP_EXECUTED,
                player=self.game_state.current_player,
                step_id=step.step_id,
                description=step.description,
                result=f"Error: {str(e)}"
            )
    
    def _process_next_queued_action(self) -> Optional[GameMessage]:
        """Process the next action from the action queue and return a message."""
            
        result = self.action_queue.process_next_action()
        if not result:
        return None
        
        return self._create_action_message(result)
    
    def _create_action_message(self, result) -> Optional[GameMessage]:
        """Create a message from an action result."""
        if not result:
        return None
        
        # Get the action that was just executed from the result
        executed_action = result.queued_action  # This contains the action info
        
        # Create a message based on the action result
        if result.success:
            # Store structured effect data for UI to format
            effect_data = self._extract_effect_data(executed_action, result)
            description = "Action completed"  # Fallback text
            
            message = StepExecutedMessage(
                type=MessageType.STEP_EXECUTED,
                player=self.game_state.current_player,
                step_id=f"action_{result.action_id}",
                description=description,
                result="Completed",
                deferred_action=result.queued_action  # Store the action for later execution
            )
            # Add structured effect data for UI formatting
            message.effect_data = effect_data
            return message
        else:
            # Error occurred
            return StepExecutedMessage(
                type=MessageType.STEP_EXECUTED,
                player=self.game_state.current_player,
                step_id=f"action_{result.action_id}_error",
                description=f"Action failed: {result.error}",
                result="Failed"
            )
    
    def _extract_effect_data(self, executed_action, result) -> dict:
        """Extract structured data about an executed effect for UI formatting."""
        if not executed_action:
        return {"type": "unknown"}
        
        from ..models.abilities.composable.effects import (
            DiscardCard, GainLoreEffect, DrawCards, BanishCharacter, 
            ReturnToHand, ExertCharacter, ReadyCharacter, RemoveDamageEffect
        )
        
        effect = executed_action.effect
        target = executed_action.target
        
        # Extract structured data based on effect type
        if isinstance(effect, DiscardCard):
            # For discard effects, get the card name and player name
            card_name = getattr(target, 'name', str(target))
            
            # Get player name from the controller or game context
            if hasattr(target, 'controller') and target.controller:
            player_name = getattr(target.controller, 'name', 'Unknown Player')
            else:
                # Fallback: look in execution context for player info
                context_player = executed_action.context.get('player')
                if context_player and hasattr(context_player, 'name'):
                player_name = context_player.name
                else:
                player_name = 'Unknown Player'
            
            return {
                "type": "discard_card",
                "card_name": card_name,
                "player_name": player_name,
                "target": target
            }
        
        elif isinstance(effect, GainLoreEffect):
        return {
                "type": "gain_lore",
                "amount": effect.amount,
                "target": target
            }
        
        elif isinstance(effect, DrawCards):
        return {
                "type": "draw_cards",
                "count": effect.count,
                "target": target
            }
        
        elif isinstance(effect, BanishCharacter):
        return {
                "type": "banish_character",
                "character_name": getattr(target, 'name', str(target)),
                "target": target
            }
        
        elif isinstance(effect, ReturnToHand):
        return {
                "type": "return_to_hand",
                "card_name": getattr(target, 'name', str(target)),
                "target": target
            }
        
        elif isinstance(effect, ExertCharacter):
        return {
                "type": "exert_character",
                "character_name": getattr(target, 'name', str(target)),
                "target": target
            }
        
        elif isinstance(effect, ReadyCharacter):
        return {
                "type": "ready_character",
                "character_name": getattr(target, 'name', str(target)),
                "target": target
            }
        
        elif isinstance(effect, RemoveDamageEffect):
        return {
                "type": "remove_damage",
                "amount": effect.amount,
                "character_name": getattr(target, 'name', str(target)),
                "target": target
            }
        
        else:
            # Generic effect data
            return {
                "type": "generic",
                "effect_class": type(effect).__name__,
                "effect_str": str(effect),
                "target_name": getattr(target, 'name', str(target)),
                "target": target,
                "source_description": executed_action.source_description
            }
    
    def _queue_result_message(self, result):
        """Queue a result message from action execution."""
            
        if result.success:
            # Create a clean result description based on action type
            description = "Action completed"
            if hasattr(result, 'result_type'):
            result_type = result.result_type.value
                
                # Create more descriptive messages
                if result_type == "ink_played":
                card = result.data.get('card') if result.data else None
                    card_name = card.name if card and hasattr(card, 'name') else 'card'
                    ink_after = result.data.get('ink_after', 0) if result.data else 0
                    total_ink = result.data.get('total_ink', 0) if result.data else 0
                    description = f"Inked {card_name}  {ink_after}/{total_ink} ink"
                elif result_type == "character_played":
                character = result.data.get('character') if result.data else None
                    char_name = character.name if character and hasattr(character, 'name') else 'character'
                    cost = character.cost if character and hasattr(character, 'cost') else 0
                    ink_after = result.data.get('ink_after', 0) if result.data else 0
                    total_ink = result.data.get('total_ink', 0) if result.data else 0
                    description = f"Played {char_name} ({cost} ink)  {ink_after}/{total_ink} ink"
                elif result_type == "character_quested":
                character = result.data.get('character') if result.data else None
                    char_name = character.name if character and hasattr(character, 'name') else 'character'
                    lore = result.data.get('lore_gained', 0) if result.data else 0
                    lore_after = result.data.get('lore_after', 0) if result.data else 0
                    description = f"{char_name} quested for {lore} lore  {lore_after} total"
                elif result_type == "character_challenged":
                attacker = result.data.get('attacker') if result.data else None
                    defender = result.data.get('defender') if result.data else None
                    attacker_name = attacker.name if attacker and hasattr(attacker, 'name') else 'character'
                    defender_name = defender.name if defender and hasattr(defender, 'name') else 'character'
                    attacker_str = attacker.current_strength if attacker and hasattr(attacker, 'current_strength') else 0
                    defender_str = defender.current_strength if defender and hasattr(defender, 'current_strength') else 0
                    attacker_dmg = result.data.get('attacker_damage_taken', 0) if result.data else 0
                    defender_dmg = result.data.get('defender_damage_taken', 0) if result.data else 0
                    description = f"{attacker_name} ({attacker_str} str) vs {defender_name} ({defender_str} str)  {defender_dmg}/{attacker_dmg} damage"
                elif result_type == "phase_advanced":
                old_phase = result.data.get('old_phase') if result.data else None
                    new_phase = result.data.get('new_phase') if result.data else None
                    old_name = old_phase.value if old_phase and hasattr(old_phase, 'value') else 'phase'
                    new_name = new_phase.value if new_phase and hasattr(new_phase, 'value') else 'phase'
                    description = f"{old_name}  {new_name} phase"
                    
                    # Evaluate conditional effects on phase change
                    self._evaluate_conditional_effects_on_phase_change()
                elif result_type == "turn_ended":
                    # Create cleaner turn transition message
                    old_player = result.data.get('old_player') if result.data else None
                    new_player = result.data.get('new_player') if result.data else None
                    new_phase = result.data.get('new_phase') if result.data else None
                    
                    if old_player and new_player and new_phase:
                    old_name = old_player.name.split(' ')[0]  # Just first name
                        new_name = new_player.name.split(' ')[0]  # Just first name  
                        phase_name = new_phase.value if hasattr(new_phase, 'value') else str(new_phase)
                        description = f"play ({old_name})  {phase_name} phase ({new_name})"
                    else:
                    description = "Turn ended"
                    
                    # Process end-of-turn effect expiration
                    self._process_turn_end_effects()
                else:
                description = result_type.replace('_', ' ').title()
            
            message = StepExecutedMessage(
                type=MessageType.STEP_EXECUTED,
                player=self.game_state.current_player,
                step_id=f"action_{result.result_type.value if hasattr(result, 'result_type') else 'unknown'}",
                description=description,
                result="Completed"
            )
            self.message_queue.append(message)
            
            # Check for zone events (conditional effect activations) and queue them as separate messages
            if result.data and result.data.get('zone_events'):
            for zone_event in result.data['zone_events']:
                event_type = zone_event.get('type', 'UNKNOWN_EVENT')
                    
                    if event_type == 'CONDITIONAL_EFFECT_APPLIED':
                    from .game_event_types import GameEventType
                        
                        zone_message = StepExecutedMessage(
                            type=MessageType.STEP_EXECUTED,
                            player=self.game_state.current_player,
                            step_id=GameEventType.CONDITIONAL_EFFECT_APPLIED.value,
                            description="",  # No description - let display layer handle it
                            result="Applied"
                        )
                        # Store the raw event data
                        zone_message.event_data = zone_event
                        self.message_queue.append(zone_message)
                    
                    elif event_type == 'CONDITIONAL_EFFECT_REMOVED':
                    from .game_event_types import GameEventType
                        
                        zone_message = StepExecutedMessage(
                            type=MessageType.STEP_EXECUTED,
                            player=self.game_state.current_player,
                            step_id=GameEventType.CONDITIONAL_EFFECT_REMOVED.value,
                            description="",  # No description - let display layer handle it
                            result="Removed"
                        )
                        # Store the raw event data
                        zone_message.event_data = zone_event
                        self.message_queue.append(zone_message)
    
    def _resolve_choice(self, choice_id: str, option: str) -> None:
        """Resolve a player choice."""
            
        # Capture the last event timestamp before choice resolution
        last_event_before = getattr(self.game_state, 'last_event', None)
        timestamp_before = last_event_before.get('timestamp', -1) if last_event_before else -1
        
        # Set up event collection for composite effects
        if not hasattr(self.game_state, 'choice_events'):
        self.game_state.choice_events = []
        
        # Clear any previous choice events
        self.game_state.choice_events.clear()
        
        # Override the choice execution to ensure game state has choice_events
        original_provide_choice = self.choice_manager.provide_choice
        def wrapped_provide_choice(choice_id, selected_option):
            # Ensure choice_events is available during effect execution
            if not hasattr(self.game_state, 'choice_events'):
            self.game_state.choice_events = []
            
            # Also ensure the context in the current choice includes the correct game state and action queue
            if self.choice_manager.current_choice:
            context = self.choice_manager.current_choice.trigger_context.get('_choice_execution_context', {})
                context['game_state'] = self.game_state
                context['action_queue'] = self.action_queue  # Add action queue for deferred execution
                self.choice_manager.current_choice.trigger_context['_choice_execution_context'] = context
                
            return original_provide_choice(choice_id, selected_option)
        
        # Temporarily replace the method
        self.choice_manager.provide_choice = wrapped_provide_choice
        
        try:
        success = self.provide_player_choice(choice_id, option)
        finally:
            # Restore original method
            self.choice_manager.provide_choice = original_provide_choice
            
        if not success:
        raise ValueError(f"Failed to resolve choice {choice_id} with option {option}")
        
        # After choice resolution, check if actions were queued and need to be processed
        if self.action_queue.has_pending_actions():
            # Process actions but DON'T apply effects yet - just prepare messages
            # Process ALL actions at once to ensure composite effects are fully split
            while self.action_queue.has_pending_actions():
            result = self.action_queue.process_next_action(apply_effect=False)
                if result:
                    # Create a message for this action (with deferred effect)
                    message = self._create_action_message(result)
                    if message:
                    self.message_queue.append(message)
    
    def _process_turn_end_effects(self) -> None:
        """Process effect expiration at end of turn."""
            
        # Get the player whose turn just ended (before the turn switch)
        # Note: The turn has already switched, so we need the previous player
        old_player_index = (self.game_state.current_player_index - 1) % len(self.game_state.players)
        ending_player = self.game_state.players[old_player_index]
        
        # Clear temporary bonuses from all characters belonging to the ending player
        for character in ending_player.characters_in_play:
        expired_effects = character.clear_temporary_bonuses(self.game_state)
            
            # Queue messages for each expired effect
            for effect in expired_effects:
            self._queue_choice_event_message(effect)
    
    def _queue_choice_event_message(self, event: dict) -> None:
        """Queue a message for a choice-triggered event."""
            
        event_type = event.get('type')
        player_name = event.get('player', 'Unknown')
        
        # Handle both enum objects and string values
        event_type_str = event_type.value if hasattr(event_type, 'value') else str(event_type)
        
        if event_type_str == 'card_drawn':
            # Queue draw event messages for choice-triggered draws
            cards_drawn = event.get('cards_drawn', [])
            for card in cards_drawn:
            card_name = card.name if hasattr(card, 'name') else 'Unknown Card'
                draw_message = StepExecutedMessage(
                    type=MessageType.STEP_EXECUTED,
                    player=self.game_state.current_player,
                    step_id=f"card_drawn",
                    description=f"{player_name} drew {card_name}",
                    result="Drew"
                )
                self.message_queue.append(draw_message)
        elif event_type_str == 'card_discarded':
            # Queue discard event messages for choice-triggered discards
            card_name = event.get('additional_data', {}).get('card_name', 'Unknown Card')
            discard_message = StepExecutedMessage(
                type=MessageType.STEP_EXECUTED,
                player=self.game_state.current_player,
                step_id=f"card_discarded",
                description=f"{player_name} discarded {card_name}",
                result="Discarded"
            )
            self.message_queue.append(discard_message)
        elif event_type_str == 'lore_gained':
            # Queue lore gain event messages for choice-triggered lore gains
            lore_amount = event.get('additional_data', {}).get('lore_amount', 0)
            lore_after = event.get('additional_data', {}).get('lore_after', 0)
            lore_message = StepExecutedMessage(
                type=MessageType.STEP_EXECUTED,
                player=self.game_state.current_player,
                step_id=f"lore_gained",
                description=f"{player_name} gained {lore_amount} lore  {lore_after} total",
                result="Gained"
            )
            self.message_queue.append(lore_message)
    
    def _get_legal_actions(self) -> List[LegalAction]:
        """Get legal actions formatted for messages."""
            
        legal_actions = []
        raw_actions = self.validator.get_all_legal_actions()
        
        for action, params in raw_actions:
        legal_action = LegalAction(
                action=action,
                target=params.get('card') or params.get('character') or params.get('attacker'),
                parameters=params
            )
            legal_actions.append(legal_action)
        
        return legal_actions
    
    def _setup_step_listeners(self) -> None:
        """Set up listeners for step events."""
            
        def on_step_completed(step: GameStep):
            # Create snapshot after each completed step
            if step.status.value == "completed":
            self.snapshot_manager.create_snapshot(
                    step.step_id, 
                    self.game_state,
                    {"step_description": step.description}
                )
        
        self.step_engine.add_step_listener(on_step_completed)
    
    def _setup_input_handlers(self) -> None:
        """Set up input handlers for different step types."""
            
        def handle_choice_input(step: GameStep, input_data: Any) -> Any:
        if not step.player_input or step.player_input.input_type != StepType.CHOICE:
            raise ValueError("Step does not require choice input")
            
            if input_data not in step.player_input.options:
            raise ValueError(f"Invalid choice: {input_data}")
            
            return step.execute_fn(input_data)
        
        def handle_selection_input(step: GameStep, input_data: Any) -> Any:
        if not step.player_input or step.player_input.input_type != StepType.SELECTION:
            raise ValueError("Step does not require selection input")
            
            if not isinstance(input_data, list):
            input_data = [input_data]
            
            constraints = step.player_input.constraints
            min_count = constraints.get('min_count', 1)
            max_count = constraints.get('max_count', 1)
            
            if len(input_data) < min_count or len(input_data) > max_count:
            raise ValueError(f"Invalid selection count: {len(input_data)}")
            
            for item in input_data:
            if item not in step.player_input.options:
                raise ValueError(f"Invalid selection: {item}")
            
            return step.execute_fn(input_data)
        
        def handle_confirmation_input(step: GameStep, input_data: Any) -> Any:
        if not step.player_input or step.player_input.input_type != StepType.CONFIRMATION:
            raise ValueError("Step does not require confirmation input")
            
            if not isinstance(input_data, bool):
            raise ValueError("Confirmation input must be boolean")
            
            return step.execute_fn(input_data)
        
        self.step_engine.register_input_handler(StepType.CHOICE, handle_choice_input)
        self.step_engine.register_input_handler(StepType.SELECTION, handle_selection_input)
        self.step_engine.register_input_handler(StepType.CONFIRMATION, handle_confirmation_input)
    
    # Conditional Effect Evaluation Methods
    @property
    def condition_evaluator(self):
        """Get or create the condition evaluator instance."""
            
        if self._condition_evaluator is None:
        from ..models.abilities.composable.condition_evaluator import ConditionEvaluator
            self._condition_evaluator = ConditionEvaluator()
        return self._condition_evaluator
    
    def _evaluate_conditional_effects_after_move(self, move: GameMove) -> None:
        """Evaluate conditional effects after a move is processed."""
            
        from ..models.abilities.composable.condition_evaluator import EvaluationTrigger
        
        # Determine trigger type based on move
        trigger = EvaluationTrigger.STEP_EXECUTED
        if isinstance(move, PlayMove):
        trigger = EvaluationTrigger.CARD_PLAYED
        elif isinstance(move, PassMove):
            # Check if this caused a phase or turn change
            trigger = EvaluationTrigger.PHASE_CHANGE
        
        # Evaluate and queue any events
        events = self.condition_evaluator.evaluate_all_conditions(self.game_state, trigger)
        self._queue_conditional_effect_events(events)
    
    def _evaluate_conditional_effects_after_step(self) -> None:
        """Evaluate conditional effects after a step is executed."""
            
        from ..models.abilities.composable.condition_evaluator import EvaluationTrigger
        
        events = self.condition_evaluator.evaluate_all_conditions(
            self.game_state, 
            EvaluationTrigger.STEP_EXECUTED
        )
        self._queue_conditional_effect_events(events)
    
    def _evaluate_conditional_effects_on_turn_change(self) -> None:
        """Evaluate conditional effects when turn changes."""
            
        from ..models.abilities.composable.condition_evaluator import EvaluationTrigger
        
        events = self.condition_evaluator.evaluate_all_conditions(
            self.game_state, 
            EvaluationTrigger.TURN_CHANGE
        )
        self._queue_conditional_effect_events(events)
    
    def _evaluate_conditional_effects_on_phase_change(self) -> None:
        """Evaluate conditional effects when phase changes."""
            
        from ..models.abilities.composable.condition_evaluator import EvaluationTrigger
        
        events = self.condition_evaluator.evaluate_all_conditions(
            self.game_state, 
            EvaluationTrigger.PHASE_CHANGE
        )
        self._queue_conditional_effect_events(events)
    
    def _queue_conditional_effect_events(self, events: List[Dict]) -> None:
        """Queue conditional effect events as messages."""
            
        for event in events:
        event_type = event.get('type')
            
            if event_type == 'CONDITIONAL_EFFECT_APPLIED':
            from .game_event_types import GameEventType
                
                message = StepExecutedMessage(
                    type=MessageType.STEP_EXECUTED,
                    player=self.game_state.current_player,
                    step_id=GameEventType.CONDITIONAL_EFFECT_APPLIED.value,
                    description="",  # No description - let display layer handle it
                    result="Applied"
                )
                # Store the raw event data for proper formatting
                message.event_data = event
                self.message_queue.append(message)
                return  # Return early to avoid duplicating the message
            
            elif event_type == 'CONDITIONAL_EFFECT_REMOVED':
            from .game_event_types import GameEventType
                
                message = StepExecutedMessage(
                    type=MessageType.STEP_EXECUTED,
                    player=self.game_state.current_player,
                    step_id=GameEventType.CONDITIONAL_EFFECT_REMOVED.value,
                    description="",  # No description - let display layer handle it
                    result="Removed"
                )
                # Store the raw event data for proper formatting
                message.event_data = event
                self.message_queue.append(message)
                return  # Return early to avoid duplicating the message
            
            else:
            description = f"Conditional effect event: {event_type}"
                
                message = StepExecutedMessage(
                    type=MessageType.STEP_EXECUTED,
                    player=self.game_state.current_player,
                    step_id=f"conditional_effect_{event_type.lower()}",
                    description=description,
                    result="Applied" if "APPLIED" in event_type else "Removed"
                )
                self.message_queue.append(message)